/*
Copyright 2019 The Fission Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package spec

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"

	"github.com/ghodss/yaml"
	uuid "github.com/satori/go.uuid"

	"github.com/fission/fission/pkg/controller/client"
	"github.com/fission/fission/pkg/fission-cli/cliwrapper/cli"
	"github.com/fission/fission/pkg/fission-cli/cmd"
	spectypes "github.com/fission/fission/pkg/fission-cli/cmd/spec/types"
	"github.com/fission/fission/pkg/fission-cli/util"
)

type InitSubCommand struct {
	client       *client.Client
	deployConfig *spectypes.DeploymentConfig
}

func Init(flags cli.Input) error {
	opts := InitSubCommand{
		client: cmd.GetServer(flags),
	}
	return opts.do(flags)
}

func (opts *InitSubCommand) do(flags cli.Input) error {
	err := opts.complete(flags)
	if err != nil {
		return err
	}
	return opts.run(flags)
}

func (opts *InitSubCommand) complete(flags cli.Input) error {
	// Figure out spec directory
	specDir := cmd.GetSpecDir(flags)

	name := flags.String("name")
	if len(name) == 0 {
		// come up with a name using the current dir
		dir, err := filepath.Abs(".")
		util.CheckErr(err, "get current working directory")
		basename := filepath.Base(dir)
		name = util.KubifyName(basename)
	}

	deployID := flags.String("deployid")
	if len(deployID) == 0 {
		deployID = uuid.NewV4().String()
	}

	// Create spec dir
	fmt.Printf("Creating fission spec directory '%v'\n", specDir)
	err := os.MkdirAll(specDir, 0755)
	util.CheckErr(err, fmt.Sprintf("create spec directory '%v'", specDir))

	// Write the deployment config
	opts.deployConfig = &spectypes.DeploymentConfig{
		TypeMeta: spectypes.TypeMeta{
			APIVersion: SPEC_API_VERSION,
			Kind:       "DeploymentConfig",
		},
		Name: name,

		// All resources will be annotated with the UID when they're created. This allows
		// us to be idempotent, as well as to delete resources when their specs are
		// removed.
		UID: deployID,
	}
	return nil
}

// run just initializes an empty spec directory and adds some
// sample YAMLs in there that might be useful.
func (opts *InitSubCommand) run(flags cli.Input) error {
	specDir := cmd.GetSpecDir(flags)

	// Add a bit of documentation to the spec dir here
	err := ioutil.WriteFile(filepath.Join(specDir, "README"), []byte(SPEC_README), 0644)
	if err != nil {
		return err
	}

	err = writeDeploymentConfig(specDir, opts.deployConfig)
	util.CheckErr(err, "write deployment config")

	// Other possible things to do here:
	// - add example specs to the dir to make it easy to manually
	//   add new ones
	return nil
}

// writeDeploymentConfig serializes the DeploymentConfig to YAML and writes it to a new
// fission-config.yaml in specDir.
func writeDeploymentConfig(specDir string, dc *spectypes.DeploymentConfig) error {
	y, err := yaml.Marshal(dc)
	if err != nil {
		return err
	}

	msg := []byte("# This file is generated by the 'fission spec init' command.\n" +
		"# See the README in this directory for background and usage information.\n" +
		"# Do not edit the UID below: that will break 'fission spec apply'\n")

	err = ioutil.WriteFile(filepath.Join(specDir, "fission-deployment-config.yaml"), append(msg, y...), 0644)
	if err != nil {
		return err
	}
	return nil
}
